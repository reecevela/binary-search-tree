"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["main"],{

/***/ "./src/Node.js":
/*!*********************!*\
  !*** ./src/Node.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Node)\n/* harmony export */ });\nclass Node {\r\n    constructor(data) {\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\n\n//# sourceURL=webpack:///./src/Node.js?");

/***/ }),

/***/ "./src/PrettyPrint.js":
/*!****************************!*\
  !*** ./src/PrettyPrint.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ prettyPrint)\n/* harmony export */ });\nfunction prettyPrint(node, prefix = '', isLeft = true) {\r\n    if (node.right !== null) {\r\n      prettyPrint(node.right, `${prefix}${isLeft ? '│   ' : '    '}`, false);\r\n    }\r\n    console.log(`${prefix}${isLeft ? '└── ' : '┌── '}${node.data}`);\r\n    if (node.left !== null) {\r\n      prettyPrint(node.left, `${prefix}${isLeft ? '    ' : '│   '}`, true);\r\n    }\r\n}\n\n//# sourceURL=webpack:///./src/PrettyPrint.js?");

/***/ }),

/***/ "./src/Tree.js":
/*!*********************!*\
  !*** ./src/Tree.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tree)\n/* harmony export */ });\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Node */ \"./src/Node.js\");\n\r\n\r\nclass Tree {\r\n    constructor(arr) {\r\n        this.root = this.buildTree(arr);\r\n    }\r\n    buildTree(arr) {\r\n        // sort array and remove duplicates\r\n        arr.sort(function(a, b) {\r\n            return a - b;\r\n        });\r\n        let duplicates = [];\r\n        let newArr = [];\r\n        let i = 0;\r\n        while (i < arr.length) {\r\n            if (duplicates.indexOf(arr[i]) == -1) {\r\n                newArr.push(arr[i]);\r\n            }\r\n            duplicates.push(arr[i]);\r\n            i++;\r\n        }\r\n        \r\n        for (let i = 0; i < newArr.length; i++) {\r\n            newArr[i] = new _Node__WEBPACK_IMPORTED_MODULE_0__[\"default\"](newArr[i]);\r\n        }\r\n\r\n        arr = newArr;\r\n\r\n        function splitArrEvenly(nodes, start, end) {\r\n            if (start > end) {\r\n                return null;\r\n            }\r\n            let midpoint = Math.ceil((start + end) / 2)\r\n            let middleNode = nodes[midpoint];\r\n\r\n            middleNode.left = splitArrEvenly(nodes, start, midpoint - 1);\r\n            middleNode.right = splitArrEvenly(nodes, midpoint + 1, end);\r\n\r\n            return middleNode;\r\n        }\r\n        this.root = splitArrEvenly(arr, 0, arr.length - 1);\r\n\r\n        return this.root;\r\n    }\r\n    insert(data) {\r\n        const newNode = new _Node__WEBPACK_IMPORTED_MODULE_0__[\"default\"](data);\r\n        const root = this.root;\r\n        if (root === null) {\r\n            this.root = newNode;\r\n        }\r\n        let current = root;\r\n        let done = false;\r\n        while (!done) {\r\n            if (newNode.data < current.data) {\r\n                if (current.left) {\r\n                    current = current.left;\r\n                } else {\r\n                    current.left = newNode;\r\n                    done = true;\r\n                    current = root;\r\n                }\r\n            } else {\r\n                if (current.right) {\r\n                    current = current.right;\r\n                } else {\r\n                    current.right = newNode;\r\n                    done = true;\r\n                    current = root;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    delete(data) {\r\n        if (this.root === null) {\r\n            return;\r\n        }\r\n    \r\n        let current = this.root;\r\n        let parent = null;\r\n        let isLeftChild = false;\r\n    \r\n        // Find the node to delete and its parent\r\n        while (current && current.data !== data) {\r\n            parent = current;\r\n            if (data < current.data) {\r\n                current = current.left;\r\n                isLeftChild = true;\r\n            } else {\r\n                current = current.right;\r\n                isLeftChild = false;\r\n            }\r\n        }\r\n    \r\n        // If the node is not found\r\n        if (current === null) {\r\n            return;\r\n        }\r\n    \r\n        // Case 1: Node with no children\r\n        if (!current.left && !current.right) {\r\n            if (current === this.root) {\r\n                this.root = null;\r\n            } else if (isLeftChild) {\r\n                parent.left = null;\r\n            } else {\r\n                parent.right = null;\r\n            }\r\n        }\r\n        // Case 2: Node with one child (left child)\r\n        else if (!current.right) {\r\n            if (current === this.root) {\r\n                this.root = current.left;\r\n            } else if (isLeftChild) {\r\n                parent.left = current.left;\r\n            } else {\r\n                parent.right = current.left;\r\n            }\r\n        }\r\n        // Case 3: Node with one child (right child)\r\n        else if (!current.left) {\r\n            if (current === this.root) {\r\n                this.root = current.right;\r\n            } else if (isLeftChild) {\r\n                parent.left = current.right;\r\n            } else {\r\n                parent.right = current.right;\r\n            }\r\n        }\r\n        // Case 4: Node with two children\r\n        else {\r\n            // Find the minimum value node in the right subtree\r\n            let minRight = current.right;\r\n            let minRightParent = current;\r\n    \r\n            while (minRight.left) {\r\n                minRightParent = minRight;\r\n                minRight = minRight.left;\r\n            }\r\n    \r\n            // Replace the current node's data with the minimum value node's data\r\n            current.data = minRight.data;\r\n    \r\n            // Remove the minimum value node from the right subtree\r\n            if (minRightParent === current) {\r\n                minRightParent.right = minRight.right;\r\n            } else {\r\n                minRightParent.left = minRight.right;\r\n            }\r\n        }\r\n    }\r\n    \r\n    find(value) {\r\n        let current = this.root;\r\n        while (current) {\r\n            if (value === current.data) {\r\n                return current;\r\n            } else if (value < current.data) {\r\n                current = current.left;\r\n            } else {\r\n                current = current.right;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    levelOrder(fn) {\r\n        let result = [];\r\n        let queue = [this.root];\r\n    \r\n        while (queue.length) {\r\n            let node = queue.shift();\r\n            if (fn) {\r\n                fn(node);\r\n            } else {\r\n                result.push(node.data);\r\n            }\r\n    \r\n            if (node.left) {\r\n                queue.push(node.left);\r\n            }\r\n            if (node.right) {\r\n                queue.push(node.right);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    inorder(fn, node = this.root) {\r\n        let result = [];\r\n    \r\n        if (node) {\r\n            result = result.concat(this.inorder(fn, node.left));\r\n            if (fn) {\r\n                fn(node);\r\n            } else {\r\n                result.push(node.data);\r\n            }\r\n            result = result.concat(this.inorder(fn, node.right));\r\n        }\r\n        return result;\r\n    }\r\n    preorder(fn, node = this.root) {\r\n        let result = [];\r\n    \r\n        if (node) {\r\n            if (fn) {\r\n                fn(node);\r\n            } else {\r\n                result.push(node.data);\r\n            }\r\n            result = result.concat(this.preorder(fn, node.left));\r\n            result = result.concat(this.preorder(fn, node.right));\r\n        }\r\n        return result;\r\n    }\r\n    postorder(fn, node = this.root) {\r\n        let result = [];\r\n    \r\n        if (node) {\r\n            result = result.concat(this.postorder(fn, node.left));\r\n            result = result.concat(this.postorder(fn, node.right));\r\n            if (fn) {\r\n                fn(node);\r\n            } else {\r\n                result.push(node.data);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    height(node) {\r\n        if (!node) {\r\n            return -1;\r\n        }\r\n        return 1 + Math.max(this.height(node.left), this.height(node.right));\r\n    }\r\n    depth(node, current = this.root) {\r\n        if (!node || !current) {\r\n            return -1;\r\n        }\r\n        if (node.data < current.data) {\r\n            return 1 + this.depth(node, current.left);\r\n        } else if (node.data > current.data) {\r\n            return 1 + this.depth(node, current.right);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    isBalanced(node = this.root) {\r\n        if (!node) {\r\n            return true;\r\n        }\r\n        const leftHeight = this.height(node.left);\r\n        const rightHeight = this.height(node.right);\r\n        return (\r\n            Math.abs(leftHeight - rightHeight) <= 1 &&\r\n            this.isBalanced(node.left) &&\r\n            this.isBalanced(node.right)\r\n        );\r\n    }\r\n    rebalance() {\r\n        const nodes = this.inorder();\r\n        this.root = this.buildTree(nodes);\r\n    }    \r\n}\n\n//# sourceURL=webpack:///./src/Tree.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tree */ \"./src/Tree.js\");\n/* harmony import */ var _PrettyPrint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PrettyPrint */ \"./src/PrettyPrint.js\");\n\r\n\r\nconst {log} = console;\r\n\r\nfunction generateRandomNumbers(size) {\r\n    const arr = [];\r\n    for (let i = 0; i < size; i++) {\r\n    arr.push(Math.floor(Math.random() * 100));\r\n    }\r\n    return arr;\r\n}\r\n\r\nconst randomNumbers = generateRandomNumbers(15);\r\nconst testTree = new _Tree__WEBPACK_IMPORTED_MODULE_0__[\"default\"](randomNumbers);\r\n\r\nlog(testTree.root);\r\n\r\n(0,_PrettyPrint__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(testTree.root);\r\n\r\nlog(\"Is the tree balanced?\", testTree.isBalanced());\r\nlog(\"Level order:\", testTree.levelOrder());\r\nlog(\"Preorder:\", testTree.preorder());\r\nlog(\"Post order:\", testTree.postorder());\r\nlog(\"In order:\", testTree.inorder());\r\n\r\n// Unbalance the tree\r\ntestTree.insert(101);\r\ntestTree.insert(102);\r\ntestTree.insert(103);\r\ntestTree.insert(104);\r\ntestTree.insert(105);\r\n\r\n// Rebalance the tree\r\ntestTree.rebalance();\r\n\r\nlog(\"Is the tree balanced after rebalancing?\", testTree.isBalanced());\r\nlog(\"Level order after rebalancing:\", testTree.levelOrder());\r\nlog(\"Pre order after rebalancing:\", testTree.preorder());\r\nlog(\"Post order after rebalancing:\", testTree.postorder());\r\nlog(\"In order after rebalancing:\", testTree.inorder());\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/index.js"));
/******/ }
]);